// Initialize dashboard when page loads
    if (window.location.pathname.endsWith('dashboard.html')) {
        document.addEventListener('DOMContentLoaded', () => {
            posSystem.showSection('dashboard');
        });
    }


// Password toggle function for login page
    function togglePassword() {
        const passwordInput = document.getElementById('password');
        const toggleIcon = document.querySelector('.password-toggle');

        if (passwordInput.type === 'password') {
            passwordInput.type = 'text';
            toggleIcon.classList.remove('slashed');
        } else {
            passwordInput.type = 'password';
            toggleIcon.classList.add('slashed');
        }

    }

You do not need to create a new table for every account (owner). Instead, you should use a relational structure with these main tables:

users — Stores all users (owners, staff, admins, etc.), with a column like owner_id to link staff/admins to their owner.
roles — Stores possible roles (e.g., Owner, Admin, Staff, or custom roles).
permissions — Stores possible permissions (e.g., view_inventory, edit_sales, etc.).
user_roles — Links users to roles (user_id, role_id).
role_permissions — Links roles to permissions (role_id, permission_id).
This way:

Each owner is a user with no owner_id (or owner_id = their own id).
Staff/admins have owner_id set to the owner's user id.
Roles and permissions are flexible and can be assigned per owner.
You do not need a new table for each account; just use relationships and foreign keys. This is scalable and standard for multi-tenant systems. If you want, I can help you design the SQL for this structure!

Yes, exactly! Each user's access will depend on their owner_id:

The owner (main account) will have their own user record (e.g., owner_id is NULL or their own id).
Any staff/admins created by the owner will have their user records with owner_id set to the owner's user id.
When a user logs in, you check their owner_id to determine which owner's data they can access.
All data (inventory, sales, etc.) should be linked to the owner_id, so only users with the same owner_id can access that owner's data.
This structure keeps each owner's data separate and lets you manage roles and permissions for each account under the same database tables.

GPT-4.1 • 0x

-- Users table: stores all users (owners, staff, admins)
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    owner_id INT DEFAULT NULL, -- NULL for owners, set to owner's id for staff/admins
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    business_name VARCHAR(100), -- Only filled for owners
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Roles table: defines possible roles
CREATE TABLE roles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    owner_id INT DEFAULT NULL, -- Roles can be global (NULL) or owner-specific
    name VARCHAR(50) NOT NULL,
    description VARCHAR(255)
);

-- Permissions table: defines possible permissions
CREATE TABLE permissions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    description VARCHAR(255)
);

-- User-Roles table: assigns roles to users
CREATE TABLE user_roles (
    user_id INT,
    role_id INT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

-- Role-Permissions table: assigns permissions to roles
CREATE TABLE role_permissions (
    role_id INT,
    permission_id INT,
    PRIMARY KEY (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);
